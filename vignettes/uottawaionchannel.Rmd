---
title: "Ion Channel Analysis"
author: "Blair Drummond"
date: "`r Sys.Date()`"
output: pdf_document
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{uottawaionchannel}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
    - \usepackage{tikz}
    - \usetikzlibrary{shapes,arrows}
---

\nocite{*}

This is a package designed to extract information on the stochastic properties of single molecules. It was originally designed for dwell time analysis of single channel data derived from patch clamp experiments. It contains functions for importing and exporting idealized stochastic events, as well as for displaying, analyzing and sorting dwells.


# Structure

This package is meant to form a simple pipeline. Most components are designed with the expectation that they can be swapped out as different methods are developed and become available.

\vspace*{0.5cm}


\begin{minipage}{0.45\textwidth}  
\begin{tikzpicture}[node distance = 3cm, auto]
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle]            (a) {Raw {\tt .evt} file};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=a] (b) {Table of transition times};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=b] (c) {Table of dwells \\(like a {\tt .dwt} file)};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=c] (d) {Table of corrected dwells};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=d] (e) {List of bursts};
    \path [draw,very thick,->] (a) -- node [right] {Read} (b);
    \path [draw,very thick,->] (b) -- node [right] {Difference data} (c);
    \path [draw,very thick,->] (c) -- node [right] {Correct durations based on filter} (d);
    \path [draw,very thick,->] (d) -- node [right] {Detect pauses and split} (e);
\end{tikzpicture}
\end{minipage}
\begin{minipage}{0.55\textwidth}
The {\tt .evt} file is what comes off the machine. It contains a lot of information, and for us the only relavent data are the times at which the amperage transitions from one discrete state to another ($0$ or $1$, for open or closed. There are no subconductive states.) An evt file looks like this (modified to fit on page): \\
\begin{verbatim}
5
File
Exchange	D:\Data\[filename]
Sweeps
1	2.000000   0.000000   [some stuff]
2	2.000000   0.000000   [some stuff]

...

Segments
1	1	0.000000	2.000000	
2	1	0.000000	2.000000	

...

Events
1	0.00026904  ...  1  0.000000E+000
1	0.00038115  ...  0  0.000000E+000
1	0.00052394  ...  1  0.000000E+000
1	0.00073063  ...  0  0.000000E+000

...

\end{verbatim}

From this, we extract the {\tt Events} section, taking the second column -the transition times- and the states (0 or 1).

\end{minipage}
   

# Example scripts

## Converting a `.evt` file to a corrected `.dwt` file

This is a simple example script showing some of the formats, and how to load and transform data.

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Load the library
library(uottawaionchannel)

# Import a pre-packaged file (stored inside the folder extdata)
infile <- system.file("extdata", "60uM.evt", package = "uottawaionchannel")

# Alternatively, you can add your own file
# infile <- "data/100uM.evt"

# Import the evt as a table
table <- evt.read(infile)


# Just transition times and states
head(table)


# Turn the transition times into dwells
record <- evt.to_dwells(table)


# a record is just a sequence of dwells
head(record)


# Correct the risetime
record_c <- risetime.correct_guassian(Tr=14.77155587,record)


# Write the corrected record to a .dwt file
dwt.write(record_c, file="60uMc.dwt")
```

## Seperating a record into bursts

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Splitting record into smaller records 
bursts_and_gaps <- bursts.separate_tcrit(record_c , 0.1)

# Extract the two parts
bursts <- bursts_and_gaps$bursts
gaps <- bursts_and_gaps$gaps

# Note that you need two brackets to access list elements.
# Also note that each burst begins and ends with a 1 state
# The gaps seperating them are the elements of gaps.
bursts[[1]]

# Write all the bursts to separate `.dwt` files + a `bursts.csv` file
dwt.write_bursts(bursts=bursts, gaps=gaps)
```

\newpage

## Plotting

A few examples of plots you can make.

### Open times and closed times


```{r, fig.show='hold', eval=TRUE, include = TRUE}
open_times <- subset(record_c, states == 1, select=dwells)$dwells

cplot.log_root_hist(open_times, main="Open Times")
```

\newpage


```{r, fig.show='hold', eval=TRUE, include = TRUE}
closed_times <- subset(record_c, states == 0, select=dwells)$dwells / 1000

cplot.log_root_hist(closed_times, main="Closed Times")
```


\newpage


### P(Open) and P(Closed)

```{r, fig.show='hold', eval=TRUE, include = TRUE}
cplot.pclosed_hist(bursts)
```

\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
cplot.pclosed_hist(bursts, y_transform=sqrt, main="P(Closed) sqrt(frequency)")
```

\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# To make this more visible, you can also export it as a large `.png` file
cplot.popen_ts(bursts)
```


\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Or, so look at a subregion 
cplot.popen_ts(bursts, xlim=c(0,250))
```


## Filtering and Sorting Bursts

### Filtering 

```{r, eval=FALSE, include = TRUE}
# Create a function to select with. 
# It's a map from a record to {TRUE,FALSE}
high_popen <- function (rec) { 

	record.popen(rec) > 0.5

}

# select filtered bursts as a list
filtered <- bursts.filter(high_popen, bursts)


length(bursts)
```
```
## [1] 733
```
```{r, eval=FALSE, include = TRUE}
length(filtered)
```
```
## [1] 728
```
 
 If you want to write these bursts to file, with the space *inbetween these bursts* zeroed out,
 
```{r, eval=FALSE, include = TRUE}
# This is just one big dwell list, not a list of lists of record.
filtered_file <- bursts.filter(high_popen, bursts, one_file=TRUE)

# Can be written directly to one file
dwt.write(filtered_file, "high-popen.dwt")
```


### Sorting

```{r, eval=TRUE, include = TRUE}
# Create a list of bursts, sorted by your chosen function
sorted <- bursts.sort(bursts, record.popen, reverse=TRUE)

# In some cases, it might be that multiple bursts share the same value
# and so the "order" is a bit arbitrary in those cases.
sorted[[1]]
```


<!--
```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```
-->
