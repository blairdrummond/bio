---
title: "Ion Channel Analysis"
author: "Blair Drummond"
date: "`r Sys.Date()`"
output: pdf_document
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{uottawaionchannel}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
    - \usepackage{tikz}
    - \usetikzlibrary{shapes,arrows}
---

\nocite{*}

This is a package designed to extract information on the stochastic properties of single molecules. It was originally designed for dwell time analysis of single channel data derived from patch clamp experiments. It contains functions for importing and exporting idealized stochastic events, as well as for displaying, analyzing and sorting dwells.


# Structure

This package is meant to form a simple pipeline. Most components are designed with the expectation that they can be swapped out as different methods are developed and become available.

\vspace*{0.5cm}


\begin{minipage}{0.45\textwidth}  
\begin{tikzpicture}[node distance = 3cm, auto]
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle]            (a) {Raw {\tt .evt} file};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=a] (b) {Table of transition times};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=b] (c) {Table of dwells \\(like a {\tt .dwt} file)};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=c] (d) {Table of corrected dwells};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=d] (e) {List of bursts};
    \path [draw,very thick,->] (a) -- node [right] {Read} (b);
    \path [draw,very thick,->] (b) -- node [right] {Difference data} (c);
    \path [draw,very thick,->] (c) -- node [right] {Correct durations based on filter} (d);
    \path [draw,very thick,->] (d) -- node [right] {Detect pauses and split} (e);
\end{tikzpicture}
\end{minipage}
\begin{minipage}{0.55\textwidth}
The {\tt .evt} file is what comes off the machine. It contains a lot of information, and for us the only relavent data are the times at which the amperage transitions from one discrete state to another ($0$ or $1$, for open or closed. There are no subconductive states.) An evt file looks like this (modified to fit on page): \\
\begin{verbatim}
5
File
Exchange	D:\Data\[filename]
Sweeps
1	2.000000   0.000000   [some stuff]
2	2.000000   0.000000   [some stuff]

...

Segments
1	1	0.000000	2.000000	
2	1	0.000000	2.000000	

...

Events
1	0.00026904  ...  1  0.000000E+000
1	0.00038115  ...  0  0.000000E+000
1	0.00052394  ...  1  0.000000E+000
1	0.00073063  ...  0  0.000000E+000

...

\end{verbatim}

From this, we extract the {\tt Events} section, taking the second column -the transition times- and the states (0 or 1).

\end{minipage}
   
   
   \newpage
   
\begin{center}   
\begin{tikzpicture}[node distance = 5cm, auto]
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle] (a) {List of bursts};
    \path [draw,very thick,->] (a) edge [loop left] node {Select or Remove Bursts} (a);
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,right of=a,dashed] (z) {Make Plots and/or Gather Statistics} (a);
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=a,dashed] (b) {Write all bursts to one .dwt};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,left of=b,dashed] (c) {Write each burst to .dwt};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,right of=b,dashed] (d) {Write all bursts to one .evt};
    \path [draw,very thick,->] (a) -- node [right] {} (b);
    \path [draw,very thick,->] (a) -- node [right] {} (c);
    \path [draw,very thick,->] (a) -- node [right] {} (d);
    \path [draw,very thick,->] (a) -- node [right] {} (z);
\end{tikzpicture}
\end{center}   
   
   
   
   
   
# Definitions and Terminology

In the program, a **segment** is used to denote any contiguous sequence of dwells (plus some metadata); so, a recording is a segment, but so are the bursts, which are contained in a recording. So, for example, a function like `bursts.defined_by_tcrit` splits a segment (the recording) into multiple smaller segments (the bursts). The segements *always* start and end on open dwells, and the closed dwells between them (interburst closings) are refered to as **gaps**.

# Example scripts

## Converting a `.evt` file to a corrected `.dwt` file

This is a simple example script showing some of the formats, and how to load and transform data.

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Load the library
library(uottawaionchannel)

# Import a pre-packaged file (stored inside the folder extdata)
infile <- system.file("extdata", "60uM.evt", package = "uottawaionchannel")

# Alternatively, you can add your own file
# infile <- "data/100uM.evt"

# Import the evt as a table
table <- evt.read(infile)


# Just transition times and states
head(table)


# Turn the transition times into dwells
record <- evt.to_dwells(table)


# "record" is a segment which is just a sequence of dwells
head(record)


# Correct the risetime
record_c <- risetime.correct_guassian(Tr=14.77155587,record)


# Write the corrected record to a .dwt file
dwt.write(record_c, file="60uMc.dwt")
```

## Seperating the record (a segment) into bursts (segments)

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Splitting segment into smaller segments 
bursts <- bursts.defined_by_tcrit(record_c , 0.1)

# Note that you need two brackets to access list elements.
# Also note that each burst begins and ends with a 1 state
# The gaps seperating them are the elements of gaps.
bursts[[1]]

# Write all the bursts to seperate `.dwt` files + a `bursts.csv` file
dwt.write_bursts(bursts=bursts)
```

## Recombining bursts into one sequence

You may wish to find all the bursts in a recording (for instance, by defining a critical time), and remove certain bursts that you aren't interested in, before analyzing your recording again with some other software. To do this, you would have to 

* Import your recording
* Define a critical time
* Select your bursts of interest
* Recombine them into **one** sequence of dwells
* Write that sequence to `.evt` or `.dwt`

To do this, one could imagine two options

**Option 1**

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Load the library
library(uottawaionchannel)

# Import a pre-packaged file (stored inside the folder extdata)
infile <- system.file("extdata", "60uM.evt", package = "uottawaionchannel")


# Import the evt as a table
table <- evt.read(infile)

# Just transition times and states
head(table)

# Turn the transition times into dwells
record <- evt.to_dwells(table)

# Correct the risetime
record_c <- risetime.correct_guassian(Tr=14.77155587,record)

# Define critical time (tcrit=0.1)
bursts <- bursts.defined_by_tcrit(record_c , 0.1)

high_popen <- function (seg) {
    segment.popen(seg) > 0.7
}

########## OPTION 1 ##############

revised_record <- bursts.select(bursts, high_popen, one_file=TRUE)

evt.write(revised_record, file="new_60mc.evt")
dwt.write(revised_record, file="new_60mc.evt")

########## END OPTION 1 ##############

######### OPTION 2 #############

high_bursts <- bursts.select(bursts, high_popen)

revised_record <- bursts.recombine(high_bursts)

evt.write(revised_record, file="new_60mc.evt")
dwt.write(revised_record, file="new_60mc.evt")

######### END OPTION 2 #############
```

These two alternative *almost* do the same thing, but not quite. The issue is that when you remove bursts (by not selecting them), you forget what happens at the beginning and end of the recording if you happen to remove the first and/or last burst that was observed. From the bursts in the middle alone, you don't even know how long the recording was, let alone how long the gap after a burst might be (if you removed all subsequent bursts). However, 

`bursts.select(bursts,func,one_file=TRUE)`

accounts for this, by creating one big segment with the unselected bursts zeroed-out (thus, you don't lose this information). So, *Option 1* is preferable here, as *Option 2* could lose information, but in many cases they may have the same result.

\newpage

## Plotting

A few examples of plots you can make.

### Open times and closed times


```{r, fig.show='hold', eval=TRUE, include = TRUE}
open_dwells <- segment.open_dwells(record_c) / 1000
hist(log10(open_dwells), axes=FALSE, breaks=30)
cplot.log_root_axes(open_dwells)
```

\newpage


```{r, fig.show='hold', eval=TRUE, include = TRUE}
closed_dwells <- segment.closed_dwells(record_c) / 1000
hist(log10(closed_dwells), axes=FALSE, breaks=30)
cplot.log_root_axes(closed_dwells)
```


\newpage


### P(Open) and P(Closed)

```{r, fig.show='hold', eval=TRUE, include = TRUE}
popens <- bursts.popens(bursts)
hist(popens, breaks=20)
```

\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
pcloseds <-bursts.pcloseds(bursts)
hist(pcloseds, breaks=20)
```

\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# To make this more visible, you can also export it as a large `.png` file
cplot.popen_ts(bursts)
```


\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Or, so look at a subregion 
cplot.popen_ts(bursts, xlim=c(0,250))
```


## Selecting and Sorting Bursts

### Selection

```{r, eval=FALSE, include = TRUE}
# Create a function to select with. 
# It's a map from a segment to {TRUE,FALSE}
high_popen <- function (rec) { 

	segment.popen(rec) > 0.5

}

# select bursts as a list
selected <- bursts.select(high_popen, bursts)


length(bursts)
```
```
## [1] 733
```
```{r, eval=FALSE, include = TRUE}
length(selected)
```
```
## [1] 728
```
 
 If you want to write these bursts to file, with the space *inbetween these bursts* zeroed out,
 
```{r, eval=FALSE, include = TRUE}
# This is just one big dwell list, not a list of lists of segment.
selected_file <- bursts.select(high_popen, bursts, one_file=TRUE)

# Can be written directly to one file
dwt.write(selected_file, "high-popen.dwt")
```


### Sorting

```{r, eval=TRUE, include = TRUE}
# Create a list of bursts, sorted by your chosen function
sorted <- bursts.sort(bursts, segment.popen, reverse=TRUE)

# In some cases, it might be that multiple bursts share the same value
# and so the "order" is a bit arbitrary in those cases.
sorted[[1]]
```


<!--
```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```
-->
