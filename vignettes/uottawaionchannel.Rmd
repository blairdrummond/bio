---
title: "Ion Channel Analysis"
author: "Blair Drummond"
date: "`r Sys.Date()`"
output: pdf_document
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{uottawaionchannel}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
    - \usepackage{tikz}
    - \usetikzlibrary{shapes,arrows}
---

\nocite{*}

This is a package designed to extract information on the stochastic properties of single molecules. It was originally designed for dwell time analysis of single channel data derived from patch clamp experiments. It contains functions for importing and exporting idealized stochastic events, as well as for displaying, analyzing and sorting dwells.


# Structure

This package is meant to form a simple pipeline. Most components are designed with the expectation that they can be swapped out as different methods are developed and become available.

\vspace*{0.5cm}


\begin{minipage}{0.45\textwidth}  
\begin{tikzpicture}[node distance = 3cm, auto]
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle]            (a) {Raw {\tt .evt} file};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=a] (b) {Table of transition times};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=b] (c) {Table of pulses \\(like a {\tt .dwt} file)};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=c] (d) {Table of "true" pulses};
    \node [draw,text badly centered, text width=10em,minimum height=4em,rectangle,below of=d] (e) {List of bursts};
    \path [draw,very thick,->] (a) -- node [right] {Read} (b);
    \path [draw,very thick,->] (b) -- node [right] {Difference data} (c);
    \path [draw,very thick,->] (c) -- node [right] {Undo effect of guassian filter} (d);
    \path [draw,very thick,->] (d) -- node [right] {Detect pauses and split} (e);
\end{tikzpicture}
\end{minipage}
\begin{minipage}{0.55\textwidth}
The {\tt .evt} file is what comes off the machine. It contains a lot of information, and for us the only relavent data are the times at which the amperage transitions from one discrete state to another ($0$ or $1$, for open or closed. There are no subconductive states.) An evt file looks like this (modified to fit on page): \\
\begin{verbatim}
5
File
Exchange	D:\Data\[filename]
Sweeps
1	2.000000   0.000000   [some stuff]
2	2.000000   0.000000   [some stuff]

...

Segments
1	1	0.000000	2.000000	
2	1	0.000000	2.000000	

...

Events
1	0.00026904  ...  1  0.000000E+000
1	0.00038115  ...  0  0.000000E+000
1	0.00052394  ...  1  0.000000E+000
1	0.00073063  ...  0  0.000000E+000

...

\end{verbatim}

From this, we extract the {\tt Events} section, taking the second column -the transition times- and the states (0 or 1).

\end{minipage}
   

# Example scripts

## Converting a `.evt` file to a corrected `.dwt` file

This is a simple example script showing some of the formats, and how to load and transform data.

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Load the library
library(uottawaionchannel)

# Import a pre-packaged file
infile <- system.file("extdata", "60uM.evt", package = "uottawaionchannel")

# Alternatively, you can add your own file
# infile <- "data/100uM.evt"

# Import the evt as a table
table <- evt.read(infile)


# Just transition times and states
head(table)


# Turn the transition times into dwells
segment <- evt.to_dwells(table)


# A segment is just a sequence of dwells
head(segment)


# Correct the risetime
segment <- risetime.correct_guassian(Tr=14.77155587,segment)


# Write the corrected dwells to a .dwt file
dwt.write(segment, "new-file-test.dwt")
```

## Seperating a segment into bursts

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Splitting a segment into subcomponents
chunks_and_breaks <- bursts.separate_tcrit(segment, 0.1)

# Extract the two parts
chunks <- chunks_and_breaks$chunks
breaks <- chunks_and_breaks$breaks

# Note that you need two brackets to access list elements.
# Also note that each chunk begins and ends with a 1 state
# The gaps seperating them are the elements of breaks.
chunks[[1]]

# Write all the bursts to separate `.dwt` files + a `bursts.csv` file
dwt.write_bursts(chunks=chunks, breaks=breaks)
```

\newpage

## Plotting

A few examples of plots you can make.

### Open times and closed times

```{r, fig.show='hold', eval=TRUE, include = TRUE}
open_times <- subset(segment, states == 1, select=dwells)$dwells

cplot.log_root_hist(open_times, "Open Times")
```

\newpage


```{r, fig.show='hold', eval=TRUE, include = TRUE}
closed_times <- subset(segment, states == 0, select=dwells)$dwells

cplot.log_root_hist(closed_times, "Closed Times")
```


\newpage


### P(Open) and P(Closed)

```{r, fig.show='hold', eval=TRUE, include = TRUE}
cplot.pclosed_hist(chunks)
```

\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
cplot.pclosed_hist(chunks, y_transform=sqrt, title="P(Closed) sqrt(frequency)")
```

\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# To make this more visible, you can also export it as a large `.png` file
cplot.popen_ts(chunks)
```


\newpage

```{r, fig.show='hold', eval=TRUE, include = TRUE}
# Or, so look at a subregion 
cplot.popen_ts(chunks, xlim=c(0,250))
```


## Filtering and Sorting Bursts

### Filtering 

```{r, eval=FALSE, include = TRUE}
# Create a function to select with. 
# It's a map from a SEGMENT to {TRUE,FALSE}
high_popen <- function (seg) { 

	segment.popen(seg) > 0.5

}

# select filtered bursts as a list
filtered <- bursts.filter(high_popen, chunks)


length(chunks)
```
```
## [1] 733
```
```{r, eval=FALSE, include = TRUE}
length(filtered)
```
```
## [1] 728
```
 
 If you want to write these bursts to file, with the space *inbetween these bursts* zeroed out,
 
```{r, eval=FALSE, include = TRUE}
# This is just one big segment, not a list of segments.
filtered_file <- bursts.filter(high_popen, chunks, one_file=TRUE)

# Can be written directly to one file
dwt.write(filtered_file, "high-popen.dwt")
```


### Sorting

```{r, eval=TRUE, include = TRUE}
# Create a list of bursts, sorted by your chosen function
sorted <- bursts.sort(chunks, segment.popen, reverse=TRUE)

# In some cases, it might be that multiple bursts share the same value
# and so the "order" is a bit arbitrary in those cases.
sorted[[1]]
```


<!--
```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```
-->
