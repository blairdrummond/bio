\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `scbursts'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Version]\AsIs{0.40}
\item[Date]\AsIs{2018-09-12}
\item[Title]\AsIs{Single Channel Bursts Analysis}
\item[Description]\AsIs{Single Channel Bursts Analysis for the daCosta Lab.}
\item[Author]\AsIs{Blair Drummond }\email{bdrum047@uottawa.ca}\AsIs{}
\item[Maintainer]\AsIs{Blair Drummond }\email{bdrum047@uottawa.ca}\AsIs{}
\item[License]\AsIs{MIT + file LICENSE}
\item[LazyData]\AsIs{true}
\item[RoxygenNote]\AsIs{6.1.1}
\item[Suggests]\AsIs{knitr, rmarkdown}
\item[VignetteBuilder]\AsIs{knitr}
\item[NeedsCompilation]\AsIs{no}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{bursts.defined\_by\_tcrit}{Divide a recording into bursts defined by a critical time.}{bursts.defined.Rul.by.Rul.tcrit}
%
\begin{Description}\relax
Split segment at long pauses, dividing the segment into multiple -shorter- segments (which are the bursts), Along with the interburst closings, which are referred to as "gaps". (Default time units are seconds)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.defined_by_tcrit(segments, t_crit, units = "s")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segments}] A segment or multiple segments with \$states and \$dwells.
NOTE: separate segments will remain split, regardless of why they were originally divided.

\item[\code{t\_crit}] Critical time at which to divide bursts (in seconds by default)

\item[\code{units}] what unit the critical time is in ('s','ms','us', or 'ns')
\end{ldescription}
\end{Arguments}
%
\begin{Value}
bursts. Which is a list of segments
starting and ending in 1 states (open dwell)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)
dwells_c <- risetime.correct_gaussian(Tr=35.0052278, dwells, unit="us")

bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")
head(bursts[[1]])

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.get\_gaps}{Get the gaps between bursts.}{bursts.get.Rul.gaps}
%
\begin{Description}\relax
Extract vector of gaps from the bursts. This is done using the start\_time attribute, which is mostly hidden in the data. (The gaps at the ends may have length 0)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.get_gaps(bursts)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] The list of segments
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of N+1 gaps for N bursts times
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)
dwells_c <- risetime.correct_gaussian(Tr=35.0052278, dwells, unit="us")

bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")
gaps <- bursts.get_gaps(bursts)

head(gaps)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.pcloseds}{Return pcloseds of every burst.}{bursts.pcloseds}
%
\begin{Description}\relax
Return pcloseds of every burst.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.pcloseds(bursts)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] The list of all bursts
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The pclosed values
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)
bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

pcloseds <- bursts.popens(bursts)
hist(pcloseds)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.popens}{Return popens of every burst.}{bursts.popens}
%
\begin{Description}\relax
Return popens of every burst.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.popens(bursts)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] The list of all bursts
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The popen values
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)
bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

popens <- bursts.popens(bursts)
hist(popens)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.recombine}{Combine bursts into one recording (with obvious spaces between them).}{bursts.recombine}
%
\begin{Description}\relax
From a list of segments, return the concatenated  segment containing all bursts. Inverse of functions like bursts.defined\_by\_tcrit
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.recombine(bursts)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] The list of all bursts
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The segment containing all bursts.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)

bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

# This is a single segment!
record <- bursts.recombine(bursts)

# Which means you can do stuff like this
open_dwells <- segment.open_dwells(bursts.recombine(bursts))

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.remove\_first\_and\_last}{Remove the first and last burst from the list.}{bursts.remove.Rul.first.Rul.and.Rul.last}
%
\begin{Description}\relax
Remove the first and last burst from the list.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.remove_first_and_last(bursts)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] The list of all bursts
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A shorter list of bursts
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)
dwells_c <- risetime.correct_gaussian(Tr=35.0052278, dwells, unit="us")

bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

# If there seem to be bad bursts at the ends
bursts <- bursts.remove_first_and_last(bursts)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.select}{From a list of bursts, extract those that interest you by passing a selecting function.}{bursts.select}
%
\begin{Description}\relax
From a list of bursts, extract those that interest you by passing a selecting function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.select(bursts, func, one_file = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] The list of all bursts

\item[\code{func}] A function of a segment that returns either TRUE or FALSE

\item[\code{one\_file}] TRUE or FALSE: Return a single file to write to disk, or a list of bursts.
The one\_file will return a file with all unselected bursts zeroed out.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A shorter list of bursts OR if one\_file is passed one segment with zeros where the other bursts might have been originally. Defaults to FALSE.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

high_popen <- function (seg) {

    segment.popen(seg) > 0.7

}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)

bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

subset <- bursts.select(bursts, high_popen)

# To export to one .dwt file
subset_f <- bursts.select(bursts, high_popen, one_file=TRUE)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.sort}{Order a list of bursts by some function. For instance, popen.}{bursts.sort}
%
\begin{Description}\relax
Order a list of bursts by some function. For instance, popen.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.sort(bursts, func, reverse = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] The list of all bursts

\item[\code{func}] A function of a segment that returns a numeric value

\item[\code{reverse}] By default, return in ascending order. Use reverse=TRUE to change that.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list sorted by func. By default in ascending order (unless reversed)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)
bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

# A sorted list of bursts. 
sorted <- bursts.sort(bursts, segment.popen)

# You can also write your own functions. If you want P(Open) =~ P(Closed)
variance_fun <- function (seg) {
    # Any function that maps a segment to a number works.
    return(  segment.popen(seg) * segment.pclosed(seg)  )
}

weird_sort <- bursts.sort(bursts, variance_fun)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.space\_out}{Artificially add amount of time between bursts (in absence of recording information).}{bursts.space.Rul.out}
%
\begin{Description}\relax
Given a list of segments separated by an unknown amount of time, one may want to space the segments by some amount of time, so that they can be plotted. This function takes a separating factor, and splits up the segments by either that factor (in seconds), or that many multiples of the largest observed dwell.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.space_out(segments, sep_factor = 1000)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segments}] The segments to space out

\item[\code{sep\_factor}] the factor by which to separate the segments.
Either the factor in seconds, or a multiple of the longest observed dwell.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The segments again, but with modified meta-data.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
infile <- system.file("extdata", "example.dwt", package = "scbursts")
dwells <- dwt.read(infile)

# Still a list, but the meta-data is fixed
spaced_records <- bursts.space_out(dwells, sep_factor=1000)

# Combine them, and they'll be nicely spaced out.
single_record <- bursts.recombine(spaced_records)

# You can now plot that single_record using one of the plot functions.

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bursts.start\_times\_update}{(DON'T USE THIS) Fix meta-data of bursts.}{bursts.start.Rul.times.Rul.update}
%
\begin{Description}\relax
YOU PROBABLY WON'T EVER HAVE TO CALL THIS DIRECTLY. Attach the meta-data to each segment saying when it began. It interleaves the durations of the bursts and gaps, and assigns the sum of those durations up to a point as the starting time.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bursts.start_times_update(bursts, gaps)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] List of segments

\item[\code{gaps}] vector of gap times.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of segments, one per burst, with updated start\_times
\end{Value}
\inputencoding{utf8}
\HeaderA{cplot.log\_root\_axes}{Add log-root axes to histogram plot}{cplot.log.Rul.root.Rul.axes}
%
\begin{Description}\relax
Add log-root axes to histogram plot
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cplot.log_root_axes(points)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{points}] The data to plot
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)
bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

open_dwells <- segment.open_dwells(bursts.recombine(bursts))
hist(log10(open_dwells), axes=FALSE, breaks=30)
cplot.log_root_axes(open_dwells)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{cplot.pclosed\_ts}{Plot Time Series (ts) of P(Closed).}{cplot.pclosed.Rul.ts}
%
\begin{Description}\relax
Plot Time Series (ts) of P(Closed).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cplot.pclosed_ts(bursts, main = "P(Closed) Time Series", xlim = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] List of multiple segments

\item[\code{main}] The title of the plot.

\item[\code{xlim}] Pass xlim argument to plot() to focus on window of time series
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)
bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

cplot.pclosed_ts(bursts, "P(Closed) Time Series, 2018-09-20")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{cplot.popen\_ts}{Plot Time Series (ts) of P(Open).}{cplot.popen.Rul.ts}
%
\begin{Description}\relax
Plot Time Series (ts) of P(Open).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cplot.popen_ts(bursts, main = "P(Open) Time Series", xlim = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bursts}] List of multiple segments

\item[\code{main}] The title of the plot.

\item[\code{xlim}] Pass xlim argument to plot() to focus on window of time series
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example_corrected.dwt", package = "scbursts")
dwells_c <- dwt.read(infile)
bursts <- bursts.defined_by_tcrit(dwells_c, 1.511842, units="s")

cplot.popen_ts(bursts, "P(Open) Time Series, 2018-09-20")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dwt.read}{Read a .dwt file.}{dwt.read}
%
\begin{Description}\relax
Read a .dwt file. Result is a list of "segments", which is a dataframe extra data. See "segment" for more details. Converts millisecond dwells to seconds.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dwt.read(filename, separating_factor = 1000)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] Filename to read from

\item[\code{separating\_factor}] In lieu of a known time between segments, seperate with a multple of the longest dwell.

\item[\code{from\_qub.}] Some .dwt files come from QUB. Set from\_qub=TRUE if .dwt from QUB.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of bursts (possibly a singleton)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)

dwt.write(dwells, file="dwells.dwt")

# Quit R, come back the next day

dwells <- dwt.read("dwells.dwt")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dwt.write}{Write a dwt file to disk. Writes DOS line endings. Dwells are in milliseconds}{dwt.write}
%
\begin{Description}\relax
Write a dwt file to disk. Writes DOS line endings. Dwells are in milliseconds
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dwt.write(segments, file = "", seg = 1, append = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segments}] A segment or multiple segments with \$dwells and \$states

\item[\code{file}] Filename to write to

\item[\code{seg}] Segment number to write in .dwt header.

\item[\code{append}] Add ot the end of a file or overwrite? (defaults to false)
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)

dwt.write(dwells, file="dwells.dwt")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{evt.extract\_header}{Extract header from evt file.}{evt.extract.Rul.header}
%
\begin{Description}\relax
Extract header from evt file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
evt.extract_header(filename)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] The filename
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A string containing the header
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")

# Get Dwells
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)
dwells_c <- risetime.correct_gaussian(Tr=35.0052278, dwells, unit="us")

# Get Header
header <- evt.extract_header(infile)

evt.write(dwells_c, header=header, file="fixed_example.evt")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{evt.from\_dwells}{Converts dwell durations to absolute transition times.}{evt.from.Rul.dwells}
%
\begin{Description}\relax
Converts dwell durations to absolute transition times.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
evt.from_dwells(segments)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segments}] A segment or multiple segemtns
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A dataframe or multiple dataframes of states and transition times
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

dwells_file <- system.file("extdata", "example.dwt", package = "scbursts")
dwells <- dwt.read(dwells_file)

transitions <- evt.from_dwells(dwells)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{evt.read}{Read a .evt file to a table. Times are in seconds}{evt.read}
%
\begin{Description}\relax
Read a .evt file to a table. Times are in seconds
\end{Description}
%
\begin{Usage}
\begin{verbatim}
evt.read(filename)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] The filename
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of tables with columns "states" and "times".
Each table corresponds to a contiguous segment from a recording.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# import some of the data included with the package
infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)

head(transitions[[1]])

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{evt.to\_dwells}{Calculate pulse lengths. Converts transition times to dwell durations.}{evt.to.Rul.dwells}
%
\begin{Description}\relax
Calculate pulse lengths. Converts transition times to dwell durations.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
evt.to_dwells(tables)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tables}] Either a single table or a list of tables with columns "states" and "times"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A segment or a list of segments with one less row, where each row
represents pulse in state 0 (closed dwell) of duration 0.51231, instead
of the time at which the state transitioned.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)
head(dwells[[1]])

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{evt.write}{Write bursts to a .evt file.}{evt.write}
%
\begin{Description}\relax
Write bursts to a .evt file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
evt.write(segments, filename = "", header = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segments}] A segment or list of segments to write to filename

\item[\code{filename}] The filename

\item[\code{header}] The header information for the evt file, if available
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")

# Get Dwells
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)
dwells_c <- risetime.correct_gaussian(Tr=35.0052278, dwells, unit="us")

# Get Header
header <- evt.extract_header(infile)

evt.write(dwells_c, header=header, file="fixed_example.evt")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{hst.extract\_header}{Extract header from hst file.}{hst.extract.Rul.header}
%
\begin{Description}\relax
Extract header from hst file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hst.extract_header(filename)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] The filename
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A string containing the header
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# import some of the data included with the package
infile <- system.file("extdata", "example.hst", package = "scbursts")

open_table <- hst.read(infile, extract="open")
closed_table <- hst.read(infile, extract="closed")
header <- hst.extract_header(infile)

# Make adjustments to the histogram, if you wish
hst.write(open_table, closed_table, file="output_hist.hst", header=header)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{hst.read}{Read a MIL ".hst" file to a table.}{hst.read}
%
\begin{Description}\relax
Read a MIL ".hst" file to a table. By default these files are in log10(Milliseconds)-sqrt(Freq), but unless "raw" is set to TRUE, this function returns a table containing Seconds-Freq
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hst.read(filename, extract = "open", raw = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] The filename

\item[\code{extract}] Extract either "open" or "closed" histogram

\item[\code{raw}] Data is given as log10(milliseconds)-Sqrt(Freq). Setting raw=FALSE yields output as Seconds-Frequency
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A tables with columns "bin", "freq" and "fit".
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# import some of the data included with the package
infile <- system.file("extdata", "example.hst", package = "scbursts")
open_hst   <- hst.read(infile, extract="open")
closed_hst <- hst.read(infile, extract="closed")

head(open_hst)
head(closed_hst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{hst.write}{Write bursts to a log10(ms)-sqrt(Frequency) .hst file from open and closed tables.}{hst.write}
%
\begin{Description}\relax
Write bursts to a log10(ms)-sqrt(Frequency) .hst file from open and closed tables.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hst.write(open_hist, closed_hist, file = "", header = NULL,
  fromraw = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{open\_hist}] The table (bin,freq,fit) for open times

\item[\code{closed\_hist}] The table (bin,freq,fit) for closed times

\item[\code{file}] The filename

\item[\code{header}] The header info

\item[\code{fromraw}] Unless FALSE, assume we need to write a log10(milliseconds)-sqrt(Frequency) plot
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.hst", package = "scbursts")

open = hst.read(infile, extract="open")
closed = hst.read(infile, extract="closed")
header = hst.extract_header(infile)

### Do stuff

hst.write(open, closed, file="new_histogram.hst", header=header)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{risetime.correct\_gaussian}{Undo the effect of the gaussian filter.}{risetime.correct.Rul.gaussian}
%
\begin{Description}\relax
Undo the effect of the gaussian filter. See section 4.1.1 of Colquhoun and Sigworth, "Fitting and Analysis of Single-Channel segments". NOTE: This is potentially problematic, in that this unfiltering lengthens every dwell. A less naive algorithm would take into account the infulence of the surroundings, as they impact the effects of the filter.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
risetime.correct_gaussian(Tr, segments, units = "s")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Tr}] Rise time of the filter in (us)

\item[\code{segments}] A segment or multiple segments with \$states and \$dwells to correct.

\item[\code{units}] What unit the risetime is input in (defaults to seconds)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A Segment or multiple segments with corrected risetimes.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

infile <- system.file("extdata", "example.evt", package = "scbursts")
transitions <- evt.read(infile)
dwells <- evt.to_dwells(transitions)

dwells_c <- risetime.correct_gaussian(Tr=35.0052278, dwells, unit="us")

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{scan.read}{Read a scan results text file. scan.read returns a 1 segment dataframe. Reads in scan results and puts them in the same format as the output of dwt.read. See 'dwt', and 'segment' for more information.}{scan.read}
%
\begin{Description}\relax
Data is in seconds.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
scan.read(filename, separating_factor = 1000)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename, }] the file name to read from.

\item[\code{separating\_factor}] In lieu of a known time between segments, 
seperate with a multple of the longest dwell.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of bursts.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
seg <- scan.read('example_scan_output.scntxt')

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.closed\_dwells}{Extract closed dwells.}{segment.closed.Rul.dwells}
%
\begin{Description}\relax
Extract closed dwells.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.closed_dwells(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the closed dwells
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

closed_dwells <- segment.closed_dwells(my_burst)
head(closed_dwells)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.count\_closed}{Extract number of closed dwells.}{segment.count.Rul.closed}
%
\begin{Description}\relax
Extract number of closed dwells.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.count_closed(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
number of closed dwells
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.count_closed(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.count\_dwells}{Extract number of dwells in segment.}{segment.count.Rul.dwells}
%
\begin{Description}\relax
Extract number of dwells in segment.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.count_dwells(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
number of dwells
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.count_dwells(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.count\_open}{Extract number of open dwells.}{segment.count.Rul.open}
%
\begin{Description}\relax
Extract number of open dwells.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.count_open(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
number of open dwells
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.count_open(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.create}{Create a "segment" object}{segment.create}
%
\begin{Description}\relax
This is a low-level function, mostly for use internally by other functions. There aren't many reasons to use this. Create object containing table data and metadata. The object can be used as a dataframe, and the metadata can be accessed with the functions: segment.seg, segment.start\_time, segment.filename
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.create(states, dwells, seg = 1, start_time = 0,
  name = "burst", ignore_errors = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{states}] a vector of states in 0,1

\item[\code{dwells}] a vector of dwell durations (same length as states)

\item[\code{seg}] The segment number. Defaults to 1

\item[\code{start\_time}] When the dwells began. Defaults to 0

\item[\code{name}] Suffix-less version of the original filename. 60uM.dwt -> '60uM'

\item[\code{ignore\_errors}] Do not report faulty segments (not many reasons to do this)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The segment object: A dataframe with extra metadata.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=0, name="example_segment")

segment.name(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.duration}{Get duration of a segment.}{segment.duration}
%
\begin{Description}\relax
Get duration of a segment.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.duration(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the duration
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.duration(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.name}{Extract name from segment.}{segment.name}
%
\begin{Description}\relax
Extract name from segment.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.name(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Segment name (string)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.name(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.open\_dwells}{Extract open dwells.}{segment.open.Rul.dwells}
%
\begin{Description}\relax
Extract open dwells.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.open_dwells(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the open dwells
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

open_dwells <- segment.open_dwells(my_burst)
head(open_dwells)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.pclosed}{Calculate empirical P(Closed) of a segment.}{segment.pclosed}
%
\begin{Description}\relax
Calculate empirical P(Closed) of a segment. NOTE: Assuming that burst starts and ends with 1
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.pclosed(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] The dwells and states table
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The ratio of closed time to total time
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

# P(Closed) of this burst
segment.pclosed(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.popen}{Calculate empirical P(Open) of a segment.}{segment.popen}
%
\begin{Description}\relax
Calculate empirical P(Open) of a segment. NOTE: Assuming that burst starts and ends with 1
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.popen(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] The dwells and states table
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The ratio of open time to total time
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

# P(Open) of this burst
segment.popen(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.seg}{Extract segment number from segment.}{segment.seg}
%
\begin{Description}\relax
Extract segment number from segment.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.seg(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Segment number (integer)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=0, name="example_segment")

segment.seg(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.start\_time}{Extract start\_time from segment.}{segment.start.Rul.time}
%
\begin{Description}\relax
Extract start\_time from segment.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.start_time(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] the segment object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Segment start\_time (float)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.start_time(my_burst)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{segment.verify}{Detect misrecorded data.}{segment.verify}
%
\begin{Description}\relax
Segments should have a very specific shape, but recordings can produce errors that make non-sensical segments. In particular, ones contain multiple consecutive openings or closings, or end in closings. This function detects whether a segment satisfies the constraint that the segment states alternate between open and closed, and begin and end with a closing.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
segment.verify(segment)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{segment}] The dwells and states table
\end{ldescription}
\end{Arguments}
%
\begin{Value}
True if a valid segment, False otherwise
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}

# It's more likely that you created states or dwells with some function
states  <-  c(0,      1,    0,    1,    0,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.0,  1.1,  0.6,  1.1,  0.8,  1.1)
my_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="example_segment")

segment.verify(my_burst)

# Now, a bad burst with two adjacent open dwells
states  <-  c(0,      1,    0,    1,    1,    0,    1,    0,    1)
dwells  <-  c(0.1,  1.1,  0.5,  0.2,  1.1,  0.6,  1.1,  0.8,  1.1)

# This will issue a warning
faulty_burst <- segment.create(states, dwells, seg=1, start_time=3.14159, name="faulty_segment")

# This will differentiate good and faulty bursts
segment.verify(faulty_burst)

# If you have a list of bursts, you can select the good ones with
# vbursts <- bursts.select(bursts, segment.verify)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{util.basename}{Remove suffix and path from filename.}{util.basename}
%
\begin{Description}\relax
Remove suffix and path from filename.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
util.basename(filename)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filename}] string to extract basename from
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Name with suffix and path removed
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
util.basename("bursts/60uM-2017-08-18-16-32/60uM-712.dwt")
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
